"""hotlist probe backfill query generator."""
import argparse
import json
import urllib.request

from jinja2 import Environment, PackageLoader

from bigquery_etl.format_sql.formatter import reformat

PROBE_INFO_SERVICE = (
    "https://probeinfo.telemetry.mozilla.org/firefox/all/main/all_probes"
)


def _get_probe_details(probe_name):
    with urllib.request.urlopen(PROBE_INFO_SERVICE) as url:
        data = json.loads(url.read())

    for key in data.keys():
        metric_type = data[key]["type"]
        probe = key.replace(f"{metric_type}/", "").replace(".", "_").lower()
        if probe == probe_name:
            channel = "nightly"
            if "nightly" not in data[key]["history"]:
                channel = "beta"

                if "beta" not in data[key]["history"]:
                    channel = "release"
            data_details = data[key]["history"][channel][0]["details"]
            metric_kind = f'{data_details["kind"]}'
            is_keyed = data_details["keyed"]
            bucket_details = None
            if metric_type == "histogram":
                bucket_details = {
                    "n_buckets": int(eval(str(data_details["n_buckets"]))),
                    "min": int(eval(str(data_details["low"]))),
                    "max": int(eval(str(data_details["high"]))),
                }
            return (metric_type, metric_kind, bucket_details, is_keyed)
    raise Exception(f"Could not find probe {probe} from {PROBE_INFO_SERVICE}")


def render_main(probe_type, **kwargs):
    """Create a SQL query for backfilling a probe."""
    env = Environment(
        loader=PackageLoader("bigquery_etl", "glam/templates/hot_probe_backfill")
    )
    main_sql = env.get_template(f"glam_backfill_{probe_type}.sql")
    return reformat(main_sql.render(**kwargs))


def main():
    """Print a glam_backfill_histogram query to stdout."""
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--probe_name",
        type=str,
        required=True,
    )
    parser.add_argument(
        "--days",
        type=int,
        default=180,
        help="Number of days to backfill",
    )
    parser.add_argument(
        "--process",
        type=str,
        default="parent",
        choices=["parent", "content", "gpu"],
        help="Choice of process [parent, content, gpu]",
    )
    parser.add_argument(
        "--source-table",
        type=str,
        help="Name of the Source table",
        default="telemetry_derived.main_1pct_v1",
    )
    parser.add_argument(
        "--project",
        type=str,
        default="moz-fx-data-shared-prod",
    )
    args = parser.parse_args()

    header = (
        "-- Query generated by: "
        "python3 -m bigquery_etl.glam.hotlist_probe_backfill "
        f"--source-table {args.source_table} "
        f"--probe_name {args.probe_name} "
        f"--days {args.days} "
        f"--process {args.process} "
        f"--project {args.project}"
    )

    (metric_type, metric_kind, bucket_details, is_keyed) = _get_probe_details(
        probe_name=args.probe_name
    )
    if metric_type not in ["histogram", "scalar"]:
        raise ValueError(f"Invalid metric type: {metric_type}")

    keyed_path = "keyed_" if is_keyed else ""
    probe_location = (
        f"payload.{keyed_path}{metric_type}s.{args.probe_name}"
        if args.process == "parent" and metric_type == "histogram"
        else f"payload.processes.{ args.process }.{metric_type}s.{ args.probe_name }"
    )

    if metric_type == "scalar":
        print(
            render_main(
                "scalars",
                header=header,
                project=args.project,
                source_table=args.source_table,
                days=args.days,
                metric=args.probe_name,
                metric_type=metric_type,
                process=args.process,
                is_keyed=is_keyed,
                probe_location=probe_location,
            )
        )
    if metric_type == "histogram":
        print(
            render_main(
                "histograms",
                header=header,
                project=args.project,
                source_table=args.source_table,
                days=args.days,
                metric=args.probe_name,
                metric_kind=metric_kind,
                process=args.process,
                is_keyed=is_keyed,
                probe_location=probe_location,
                first_bucket=bucket_details["min"],
                last_bucket=bucket_details["max"],
                num_buckets=bucket_details["n_buckets"],
            )
        )


if __name__ == "__main__":
    main()
